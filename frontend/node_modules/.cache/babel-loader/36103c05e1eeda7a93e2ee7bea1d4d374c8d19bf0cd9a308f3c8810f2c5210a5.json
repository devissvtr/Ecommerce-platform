{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from \"rehackt\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { createMakeWatchQueryOptions, getDefaultFetchPolicy, getObsQueryOptions, toQueryResult, useQueryInternals } from \"./useQuery.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nvar EAGER_METHODS = [\"refetch\", \"reobserve\", \"fetchMore\", \"updateQuery\", \"startPolling\", \"stopPolling\", \"subscribeToMore\"];\n/**\n * A hook for imperatively executing queries in an Apollo application, e.g. in response to user interaction.\n *\n * > Refer to the [Queries - Manual execution with useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery) section for a more in-depth overview of `useLazyQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useLazyQuery } from \"@apollo/client\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const [loadGreeting, { called, loading, data }] = useLazyQuery(\n *     GET_GREETING,\n *     { variables: { language: \"english\" } }\n *   );\n *   if (called && loading) return <p>Loading ...</p>\n *   if (!called) {\n *     return <button onClick={() => loadGreeting()}>Load greeting</button>\n *   }\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Default options to control how the query is executed.\n * @returns A tuple in the form of `[execute, result]`\n */\nexport function useLazyQuery(query, options) {\n  var _a;\n  var execOptionsRef = React.useRef(void 0);\n  var optionsRef = React.useRef(void 0);\n  var queryRef = React.useRef(void 0);\n  var merged = mergeOptions(options, execOptionsRef.current || {});\n  var document = (_a = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a !== void 0 ? _a : query;\n  // Use refs to track options and the used query to ensure the `execute`\n  // function remains referentially stable between renders.\n  optionsRef.current = options;\n  queryRef.current = document;\n  var queryHookOptions = __assign(__assign({}, merged), {\n    skip: !execOptionsRef.current\n  });\n  var _b = useQueryInternals(document, queryHookOptions),\n    obsQueryFields = _b.obsQueryFields,\n    useQueryResult = _b.result,\n    client = _b.client,\n    resultData = _b.resultData,\n    observable = _b.observable,\n    onQueryExecuted = _b.onQueryExecuted;\n  var initialFetchPolicy = observable.options.initialFetchPolicy || getDefaultFetchPolicy(queryHookOptions.defaultOptions, client.defaultOptions);\n  var forceUpdateState = React.useReducer(function (tick) {\n    return tick + 1;\n  }, 0)[1];\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  var eagerMethods = React.useMemo(function () {\n    var eagerMethods = {};\n    var _loop_1 = function (key) {\n      var method = obsQueryFields[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          forceUpdateState();\n        }\n        // @ts-expect-error this is just too generic to type\n        return method.apply(this, arguments);\n      };\n    };\n    for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {\n      var key = EAGER_METHODS_1[_i];\n      _loop_1(key);\n    }\n    return eagerMethods;\n  }, [forceUpdateState, obsQueryFields]);\n  var called = !!execOptionsRef.current;\n  var result = React.useMemo(function () {\n    return __assign(__assign(__assign({}, useQueryResult), eagerMethods), {\n      called: called\n    });\n  }, [useQueryResult, eagerMethods, called]);\n  var execute = React.useCallback(function (executeOptions) {\n    execOptionsRef.current = executeOptions ? __assign(__assign({}, executeOptions), {\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy\n    }) : {\n      fetchPolicy: initialFetchPolicy\n    };\n    var options = mergeOptions(optionsRef.current, __assign({\n      query: queryRef.current\n    }, execOptionsRef.current));\n    var promise = executeQuery(resultData, observable, client, document, __assign(__assign({}, options), {\n      skip: false\n    }), onQueryExecuted).then(function (queryResult) {\n      return Object.assign(queryResult, eagerMethods);\n    });\n    // Because the return value of `useLazyQuery` is usually floated, we need\n    // to catch the promise to prevent unhandled rejections.\n    promise.catch(function () {});\n    return promise;\n  }, [client, document, eagerMethods, initialFetchPolicy, observable, resultData, onQueryExecuted]);\n  var executeRef = React.useRef(execute);\n  useIsomorphicLayoutEffect(function () {\n    executeRef.current = execute;\n  });\n  var stableExecute = React.useCallback(function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return executeRef.current.apply(executeRef, args);\n  }, []);\n  return [stableExecute, result];\n}\nfunction executeQuery(resultData, observable, client, currentQuery, options, onQueryExecuted) {\n  var query = options.query || currentQuery;\n  var watchQueryOptions = createMakeWatchQueryOptions(client, query, options, false)(observable);\n  var concast = observable.reobserveAsConcast(getObsQueryOptions(observable, client, options, watchQueryOptions));\n  onQueryExecuted(watchQueryOptions);\n  return new Promise(function (resolve) {\n    var result;\n    // Subscribe to the concast independently of the ObservableQuery in case\n    // the component gets unmounted before the promise resolves. This prevents\n    // the concast from terminating early and resolving with `undefined` when\n    // there are no more subscribers for the concast.\n    concast.subscribe({\n      next: function (value) {\n        result = value;\n      },\n      error: function () {\n        resolve(toQueryResult(observable.getCurrentResult(), resultData.previousData, observable, client));\n      },\n      complete: function () {\n        resolve(toQueryResult(observable[\"maskResult\"](result), resultData.previousData, observable, client));\n      }\n    });\n  });\n}\n//# sourceMappingURL=useLazyQuery.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}