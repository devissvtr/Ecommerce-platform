{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { createFulfilledPromise, wrapPromiseWithState } from \"../../../utilities/index.js\";\nvar FragmentReference = /** @class */function () {\n  function FragmentReference(client, watchFragmentOptions, options) {\n    var _this = this;\n    this.key = {};\n    this.listeners = new Set();\n    this.references = 0;\n    this.dispose = this.dispose.bind(this);\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.observable = client.watchFragment(watchFragmentOptions);\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n    var diff = this.getDiff(client, watchFragmentOptions);\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this fragmentRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    var startDisposeTimer = function () {\n      var _a;\n      if (!_this.references) {\n        _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 30000);\n      }\n    };\n    this.promise = diff.complete ? createFulfilledPromise(diff.result) : this.createPendingPromise();\n    this.subscribeToFragment();\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n  FragmentReference.prototype.listen = function (listener) {\n    var _this = this;\n    this.listeners.add(listener);\n    return function () {\n      _this.listeners.delete(listener);\n    };\n  };\n  FragmentReference.prototype.retain = function () {\n    var _this = this;\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    var disposed = false;\n    return function () {\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      _this.references--;\n      setTimeout(function () {\n        if (!_this.references) {\n          _this.dispose();\n        }\n      });\n    };\n  };\n  FragmentReference.prototype.dispose = function () {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  };\n  FragmentReference.prototype.onDispose = function () {\n    // noop. overridable by options\n  };\n  FragmentReference.prototype.subscribeToFragment = function () {\n    this.subscription = this.observable.subscribe(this.handleNext.bind(this), this.handleError.bind(this));\n  };\n  FragmentReference.prototype.handleNext = function (result) {\n    var _a;\n    switch (this.promise.status) {\n      case \"pending\":\n        {\n          if (result.complete) {\n            return (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, result.data);\n          }\n          this.deliver(this.promise);\n          break;\n        }\n      case \"fulfilled\":\n        {\n          // This can occur when we already have a result written to the cache and\n          // we subscribe for the first time. We create a fulfilled promise in the\n          // constructor with a value that is the same as the first emitted value\n          // so we want to skip delivering it.\n          if (equal(this.promise.value, result.data)) {\n            return;\n          }\n          this.promise = result.complete ? createFulfilledPromise(result.data) : this.createPendingPromise();\n          this.deliver(this.promise);\n        }\n    }\n  };\n  FragmentReference.prototype.handleError = function (error) {\n    var _a;\n    (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, error);\n  };\n  FragmentReference.prototype.deliver = function (promise) {\n    this.listeners.forEach(function (listener) {\n      return listener(promise);\n    });\n  };\n  FragmentReference.prototype.createPendingPromise = function () {\n    var _this = this;\n    return wrapPromiseWithState(new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n    }));\n  };\n  FragmentReference.prototype.getDiff = function (client, options) {\n    var cache = client.cache;\n    var from = options.from,\n      fragment = options.fragment,\n      fragmentName = options.fragmentName;\n    var diff = cache.diff(__assign(__assign({}, options), {\n      query: cache[\"getFragmentDoc\"](fragment, fragmentName),\n      returnPartialData: true,\n      id: from,\n      optimistic: true\n    }));\n    return __assign(__assign({}, diff), {\n      result: client[\"queryManager\"].maskFragment({\n        fragment: fragment,\n        fragmentName: fragmentName,\n        data: diff.result\n      })\n    });\n  };\n  return FragmentReference;\n}();\nexport { FragmentReference };\n//# sourceMappingURL=FragmentReference.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}